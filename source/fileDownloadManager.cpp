//**********************************************************************************************************************************
//
// PROJECT:             QCL
// FILE:			          fileDownloadManager
// SUBSYSTEM:           Download files from a URL
// TARGET OS:	          WINDOWS, LINUX, UNIX, MAC
// NAMESPACE:						QCL
// AUTHOR:              Gavin Blakeman
// LICENSE:             GPLv2
//
//                      Copyright 2020 Gavin Blakeman.
//                      This file is part of the Qt Class Library (QCL)
//
//                      QCL is free software: you can redistribute it and/or modify it under the terms of the GNU General
//                      Public License as published by the Free Software Foundation, either version 2 of the License, or (at your
//                      option) any later version.
//
//                      QCL is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
//                      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
//                      License for more details.
//
//                      You should have received a copy of the GNU General Public License along with QCL.  If not,
//                      see <http://www.gnu.org/licenses/>.
//
// OVERVIEW:
//
// CLASSES:
//
// HISTORY:             2020-10-03 GGB - File created.
//
//**********************************************************************************************************************************

#include "include/fileDownloadManager.h"

  // Miscellaneous library header files

#include "boost/format.hpp"
#include "boost/locale.hpp"
#include <GCL>

namespace QCL
{
  std::uint32_t CFileDownloadManager::downloadUID(0);

  /// @brief      Default constructor
  /// @throws     std::bad_alloc
  /// @version    2020-10-03/GGB - Function created.

  CFileDownloadManager::CFileDownloadManager()
  {
    connect(&networkManager, SIGNAL(finished(QNetworkReply*)), this, SLOT(finished(QNetworkReply*)));
  }

  /// @brief      Constructs a QList of QNetworkReply
  /// @param[in]  url: The URL to perform the download from.
  /// @param[in]  filename: The filename to save as.
  /// @param[in]  successFN: The callback function if succeeded.
  /// @param[in]  errorFN: THe callback function if the download and save did not succeed.
  /// @returns    The unique transaction ID.
  /// @throws
  /// @version    2020-10-03/GGB - Function created.

  std::uint32_t CFileDownloadManager::startDownload(QUrl const &url, boost::filesystem::path const &filename,
                                                    callback_fn successFN, callback_fn errorFN)
  {
    QNetworkRequest request(url);
    QNetworkReply *reply = networkManager.get(request);

#ifndef QT_NO_SSL
    connect(reply, SIGNAL(sslErrors(QList<QSslError>)), SLOT(sslErrors(QList<QSslError>)));
#endif

    currentDownloads.insert(reply, {++downloadUID, filename, successFN, errorFN});

    return downloadUID;
  }

  /// @brief      Slot called when a pending network reply is finished.
  /// @param[in]  reply: The reply generated by the network manager.
  /// @throws
  /// @version    2020-10-03/GGB - Function created.

  void CFileDownloadManager::finished(QNetworkReply *reply)
  {
    if (reply->error())
    {
      if (currentDownloads.value(reply).errorCallback)
      {
        currentDownloads.value(reply).errorCallback(currentDownloads.value(reply).uniqueID, reply);
      };
    }
    else
    {
      QString filename = QString::fromStdString(currentDownloads.value(reply).filename.string());

      if (!filename.isEmpty())
      {
        if (saveToDisk(filename, reply))
        {
          if (currentDownloads.value(reply).successCallback)
          {
            currentDownloads.value(reply).successCallback(currentDownloads.value(reply).uniqueID, reply);
          };
        }
        else
        {
          if (currentDownloads.value(reply).errorCallback)
          {
            currentDownloads.value(reply).errorCallback(currentDownloads.value(reply).uniqueID, reply);
          };
        };
      };
    };

    currentDownloads.remove(reply);
    reply->deleteLater();
  }

  /// @brief      Saves the data to disk.
  /// @param[in]  filename: The name and path of the file to save.
  /// @param[in]  reply: The network reply with the data to save.
  /// @returns
  /// @throws
  /// @version    2020-10-03/GGB - Function created.

  bool CFileDownloadManager::saveToDisk(QString const &filename, QIODevice *reply)
  {
    QFile file(filename);

    if (!file.open(QIODevice::WriteOnly))
    {
      ERRORMESSAGE(boost::format(boost::locale::translate("Could not open %s for writing: %s").str())
                   % filename.toStdString() % file.errorString().toStdString());
      return false;
    }
    else
    {
      file.write(reply->readAll());
      file.close();
      INFOMESSAGE(boost::format(boost::locale::translate("File saved: %s").str()) % filename.toStdString());
    };

    return true;
  }

  /// @brief      Handle SSL errors.
  /// @param[in]  sslErrors: The list of SSL errors.
  /// @throws
  /// @version    2020-10-03/GGB - Function created.

  void CFileDownloadManager::sslErrors(const QList<QSslError> &sslErrors)
  {
  #ifndef QT_NO_SSL
    foreach (QSslError const &error, sslErrors)
    {
      fprintf(stderr, "SSL error: %s\n", qPrintable(error.errorString()));
    };
  #else
      Q_UNUSED(sslErrors);
  #endif
  }



}
